/*   The MIT License
 *
 *   Tempest Engine
 *   Copyright (c) 2014 Zdravko Velinov
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */

options
{
    @MaterialSpecular,
    @MaterialAmbient,
    @MaterialFormat
    {
        @MaterialTexture,
        @MaterialColor
    }
}

constant buffer SceneParams
{
    vec3 CameraPosition;
    vec3 SunDirection;
}

struct GlobalsDesc
{
    mat4 Transform;
    vec4 DiffuseReflectivity;              // Kd, sharpness
    @MaterialSpecular vec4 Specular;       // Ks, Ns
    @MaterialAmbient vec4 AmbientDissolve; // Ka, d (alpha)
//  vec4 Transmission;                     // Tf, Ni
    @MaterialTexture
    {
        uint DiffuseReflectivityMap;       // map_Kd
        uint DissolveMap;                  // map_d
        @MaterialSpecular
        {
            uint SpecularReflectivityMap;  // map_Ks
            uint SpecularExponentMap;      // map_Ns
        }
        @MaterialAmbient uint AmbientReflectivityMap;   // map_Ka
    }
};

void GetResourceIndex(in uint packed_res_idx, out uint tex_slot, out uint tex_slice)
{
    tex_slot  = packed_res_idx >> 16;
    tex_slice = packed_res_idx & 0xFFFF;
}

// The main reason is APIs that support some non-bindless weirdness for the old hardware
// sake.
resources ResourcesTable
{
    sampler2DArray Textures[16];
}

structbuffer GlobalsDesc Globals;

// TODO: Position should be vec3

vertex shader VS
{
    in vec4 Position;
    @MaterialTexture in vec2 TexCoord;
    in vec3 Normal;
    
    out vec2 InterpTexCoord;
    out vec3 InterpNormal;
    out vec3 InterpView;
    
    flat out int DrawIndex;
    
    void main()
    {
        DrawIndex = tge_DrawID;
        @MaterialTexture InterpTexCoord = TexCoord;
        InterpNormal = Normal;
        InterpView = CameraPosition - Position.xyz/Position.w;
        gl_Position = Globals[tge_DrawID].Transform*Position;
    }
}

fragment shader FS
{
    flat in int DrawIndex;

    @MaterialTexture in vec2 InterpTexCoord;
    in vec3 InterpNormal;
    in vec3 InterpView;
    
    out vec4 FragmentColor;
    
    void main()
    {
        vec3 eye = normalize(InterpView);
        vec3 normal = normalize(InterpNormal);
        vec4 ambient, diffuse, specular;
        vec4 ambient = Globals[DrawIndex].AmbientDissolve;
        vec4 diffuse = Globals[DrawIndex].DiffuseReflectivity;
        @MaterialSpecular vec4 specular = Globals[DrawIndex].Specular.xyz;
    
        @MaterialTexture
        {
            uint ambient_slot, ambient_slice,
                 diffuse_slot, diffuse_slice,
                 specular_slot, specular_slice,
                 dissolve_slot, dissolve_slice,
                 specular_exp_slot, specular_exp_slice;

            GetResourceIndex(Globals[DrawIndex].AmbientReflectivityMap, ambient_slot, ambient_slice);
            GetResourceIndex(Globals[DrawIndex].DiffuseReflectivityMap, diffuse_slot, diffuse_slice);
            GetResourceIndex(Globals[DrawIndex].SpecularReflectivityMap, specular_slot, specular_slice);
            GetResourceIndex(Globals[DrawIndex].DissolveMap, dissolve_slot, dissolve_slice);
            GetResourceIndex(Globals[DrawIndex].SpecularExponentMap, specular_exp_slot, specular_exp_slice);

            diffuse.xyz *= texture(Textures[diffuse_slot], vec3(InterpTexCoord, float(diffuse_slice)).xyz;
            specular.xyz *= texture(Textures[specular_slot], vec3(InterpTexCoord, float(specular_slice)).xyz;
            ambient.w *= texture(Textures[dissolve_slot], vec3(InterpTexCoord, float(dissolve_slice)).x;
            @MaterialSpecular specular.w = texture(Textures[specular_exp_slot], vec3(InterpTexCoord, specular_exp_slice)).x;
            @MaterialAmbient ambient.xyz *= texture(Textures[ambient_slot], vec3(InterpTexCoord, float(ambient_slice)).xyz;
        }

        vec3 color = diffuse.xyz*dot(light, normal);

        @MaterialSpecular
        {
            vec3 half_vec = normalize(eye + normal);
            color += specular.xyz*pow(dot(half_vec, SunDirection), specular.w);
        }

        @MaterialAmbient color += ambient.xyz;
        
        FragmentColor = vec4(color, ambient.w);
    }
}