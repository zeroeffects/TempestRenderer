/*
*
*   Tempest Engine
*   Copyright(c) 2015 Zdravko Velinov
*
*   Permission is hereby granted, free of charge, to any person obtaining a copy
*   of this software and associated documentation files(the "Software"), to deal
*   in the Software without restriction, including without limitation the rights
*   to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
*   copies of the Software, and to permit persons to whom the Software is
*   furnished to do so, subject to the following conditions :
*
*   The above copyright notice and this permission notice shall be included in
*   all copies or substantial portions of the Software.
*
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
*   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*   THE SOFTWARE.
*/

options
{
    AdHocPhong,
    AdHocBlinnPhong
}

constant buffer SceneParams
{
    vec3 CameraPosition;
    vec3 SunDirection;
}

struct GlobalsDesc
{
    mat4 WorldViewProjectionTransform;
    mat4 RotateTransform;
    vec4 CubeID;
    vec4 Diffuse;
    vec4 Specular;
    vec4 Environment;
};

// The main reason is APIs that support some non-bindless weirdness for the old hardware sake.
resource buffer ResourcesTable
{
    sampler2DArray Textures[4];
    samplerCubeArray TextureCubes;
}

structbuffer GlobalsDesc Globals;

// TODO: Position should be vec3

// Naive
vec3 SRGBDecode(vec3 color)
{
    return pow(color, vec3(2.2, 2.2, 2.2));
}

vec3 SRGBEncode(vec3 color)
{
    return pow(color, vec3(1.0/2.2, 1.0/2.2, 1.0/2.2));
}

vertex shader
{
    layout(vb_pack_align = 4, vb_format = RGBA32F) in vec4 Position;
    layout(vb_pack_align = 4, vb_format = RG32F) in vec2 TexCoord;
    layout(vb_pack_align = 4, vb_format = RGB32F) in vec3 Normal;

    out vec3 InterpNormal;
    out vec3 InterpView;

    flat out int DrawIndex;

    void main()
    {
        DrawIndex = tge_DrawID;
        InterpNormal = mat3(Globals[tge_DrawID].RotateTransform)*Normal;
        InterpView = CameraPosition - Position.xyz / Position.w;
        gl_Position = Globals[tge_DrawID].WorldViewProjectionTransform*Position;
    }
}

@AdHocPhong
{
fragment shader
{
    flat in int DrawIndex;

    in vec3 InterpNormal;
    in vec3 InterpView;

    out vec4 FragmentColor;

    void main()
    {
        vec3 eye = normalize(InterpView);
        vec3 normal = normalize(InterpNormal);
        float alpha = 1.0;

        vec4 diffuse = Globals[DrawIndex].Diffuse;
        vec4 specular = Globals[DrawIndex].Specular;
        vec4 environment = Globals[DrawIndex].Environment;
        vec4 cube_tex = Globals[DrawIndex].CubeID;

        diffuse.xyz = SRGBDecode(diffuse.xyz);
        specular.xyz = SRGBDecode(specular.xyz);
        environment.xyz = SRGBDecode(environment.xyz);

        vec3 refl_vec = normalize(reflect(-eye, normal));

        vec3 color = diffuse.xyz;

        // The bad assumption that the sun is so powerful that it just adds its color
        color += specular.xyz*pow(clamp(dot(refl_vec, SunDirection), 0.0, 1.0), specular.w);

        color *= max(0.0, dot(SunDirection, normal));

        vec3 env_color = environment.xyz*SRGBDecode(texture(TextureCubes, vec4(refl_vec, cube_tex.w)).xyz);

        float dot_refl = max(0.0, dot(normal, eye));
        float fresnel = mix(pow(1.0 - dot_refl, 5.0), 1.0, environment.w);

        color += env_color*fresnel;

        FragmentColor = vec4(SRGBEncode(color), alpha);
    }
}
}

@AdHocBlinnPhong
{
fragment shader
{
    flat in int DrawIndex;

    in vec3 InterpNormal;
    in vec3 InterpView;

    out vec4 FragmentColor;

    void main()
    {
        vec3 eye = normalize(InterpView);
        vec3 normal = normalize(InterpNormal);
        float alpha = 1.0;

        vec4 diffuse = Globals[DrawIndex].Diffuse;
        vec4 specular = Globals[DrawIndex].Specular;
        vec4 environment = Globals[DrawIndex].Environment;
        vec4 cube_tex = Globals[DrawIndex].CubeID;

        diffuse.xyz = SRGBDecode(diffuse.xyz);
        specular.xyz = SRGBDecode(specular.xyz);
        environment.xyz = SRGBDecode(environment.xyz);

        vec3 refl_vec = normalize(reflect(-eye, normal));
        vec3 half_vec = normalize(eye + SunDirection);

        vec3 color = diffuse.xyz;

        // The bad assumption that the sun is so powerful that it just adds its color
        color += specular.xyz*pow(clamp(dot(half_vec, normal), 0.0, 1.0), specular.w);

        color *= max(0.0, dot(SunDirection, normal));

        vec3 env_color = environment.xyz*SRGBDecode(texture(TextureCubes, vec4(refl_vec, cube_tex.w)).xyz);

        float dot_refl = max(0.0, dot(normal, eye));
        float fresnel = mix(pow(1.0 - dot_refl, 5.0), 1.0, environment.w);

        color += env_color*fresnel;

        FragmentColor = vec4(SRGBEncode(color), alpha);
    }
}
}