/*   The MIT License
 *
 *   Tempest Engine
 *   Copyright (c) 2014 Zdravko Velinov
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */

options
{
    MaterialSpecular,
    MaterialAmbient,
    MaterialTexture
}

constant buffer SceneParams
{
    vec3 CameraPosition;
    vec3 SunDirection;
}

struct GlobalsDesc
{
    mat4 Transform;
    vec4 DiffuseReflectivity;              // Kd, sharpness
    @MaterialSpecular vec4 Specular;       // Ks, Ns
    @MaterialAmbient vec4 AmbientDissolve; // Ka, d (alpha)
//  vec4 Transmission;                     // Tf, Ni
    @MaterialTexture
    {
        uint DiffuseReflectivityMap;       // map_Kd
        uint DissolveMap;                  // map_d
        @MaterialSpecular
        {
            uint SpecularReflectivityMap;  // map_Ks
            uint SpecularExponentMap;      // map_Ns
        }
        @MaterialAmbient uint AmbientReflectivityMap;   // map_Ka
    }
};

void GetResourceIndex(in uint packed_res_idx, out uint tex_slot, out uint tex_slice)
{
    tex_slot  = packed_res_idx >> 16;
    tex_slice = packed_res_idx & 0xFFFFu;
}

// The main reason is APIs that support some non-bindless weirdness for the old hardware sake.
resource buffer ResourcesTable
{
    sampler2DArray Textures[16];
}

structbuffer GlobalsDesc Globals;

// TODO: Position should be vec3

vertex shader
{
    in vec4 Position;
    @MaterialTexture in vec2 TexCoord;
    in vec3 Normal;
    
    out vec2 InterpTexCoord;
    out vec3 InterpNormal;
    @MaterialSpecular out vec3 InterpView;
    
    flat out int DrawIndex;
    
    void main()
    {
        DrawIndex = tge_DrawID;
        @MaterialTexture InterpTexCoord = TexCoord;
        InterpNormal = Normal;
        @MaterialSpecular InterpView = CameraPosition - Position.xyz/Position.w;
        gl_Position = Globals[tge_DrawID].Transform*Position;
    }
}

fragment shader
{
    flat in int DrawIndex;

    @MaterialTexture in vec2 InterpTexCoord;
    in vec3 InterpNormal;
    @MaterialSpecular in vec3 InterpView;
    
    out vec4 FragmentColor;
    
    void main()
    {
        @MaterialSpecular vec3 eye = normalize(InterpView);
        vec3 normal = normalize(InterpNormal);
        float alpha = 1.0;
        @MaterialAmbient
        {
            vec4 ambient = Globals[DrawIndex].AmbientDissolve;
            alpha = ambient.w;
        }
        vec4 diffuse = Globals[DrawIndex].DiffuseReflectivity;
        @MaterialSpecular vec4 specular = Globals[DrawIndex].Specular;
    
        @MaterialTexture
        {
            uint diffuse_slot, diffuse_slice,
                 dissolve_slot, dissolve_slice;

            GetResourceIndex(Globals[DrawIndex].DissolveMap, dissolve_slot, dissolve_slice);
            GetResourceIndex(Globals[DrawIndex].DiffuseReflectivityMap, diffuse_slot, diffuse_slice);

            diffuse.xyz *= texture(Textures[diffuse_slot], vec3(InterpTexCoord, float(diffuse_slice))).xyz;
            @MaterialAmbient
            {
                uint ambient_slot, ambient_slice;
                GetResourceIndex(Globals[DrawIndex].AmbientReflectivityMap, ambient_slot, ambient_slice);
                ambient.xyz *= texture(Textures[ambient_slot], vec3(InterpTexCoord, float(ambient_slice))).xyz;
                alpha *= texture(Textures[dissolve_slot], vec3(InterpTexCoord, float(dissolve_slice))).x;
            }
            @MaterialSpecular
            {
                uint specular_slot, specular_slice,
                     specular_exp_slot, specular_exp_slice;
                GetResourceIndex(Globals[DrawIndex].SpecularReflectivityMap, specular_slot, specular_slice);
                GetResourceIndex(Globals[DrawIndex].SpecularExponentMap, specular_exp_slot, specular_exp_slice);
                specular.xyz *= texture(Textures[specular_slot], vec3(InterpTexCoord, float(specular_slice))).xyz;
                specular.w = texture(Textures[specular_exp_slot], vec3(InterpTexCoord, float(specular_exp_slice))).x;
            }
        }

        vec3 color = diffuse.xyz*dot(SunDirection, normal);

        @MaterialSpecular
        {
            vec3 half_vec = normalize(eye + normal);
            color += specular.xyz*pow(dot(half_vec, SunDirection), specular.w);
        }

        @MaterialAmbient color += ambient.xyz;
        
        FragmentColor = vec4(color, alpha);
    }
}