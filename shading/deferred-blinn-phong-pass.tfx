/*   The MIT License
 *
 *   Tempest Engine
 *   Copyright (c) 2016 Zdravko Velinov
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */

options
{
    PointLight,
    DirectionalLight
} 

resource buffer ResourcesTable
{
    sampler2DArray Textures[4];
    samplerCubeArray TextureCubes;
    sampler2D GBufferDepth;
    sampler2D GBuffer0;
    sampler2D GBuffer1;
    sampler2D GBuffer2;
}

constant buffer SceneData
{
    mat4 ViewProjectionTransform;
    mat4 ViewProjectionInverseTransform;
    vec3 CameraPosition;
}

struct GlobalsDesc
{
    @PointLight vec4 LightGeometry;
    @DirectionalLight vec3 LightDirection;
    vec3 Radiance;
};

structbuffer GlobalsDesc Globals;

// TODO: Include files that are not raw imports

// Note that it outputs view space normal
vec3 LambertEqualAreaToCartesianCoordinates(vec2 enc)
{
    vec2 fenc = enc*4.0 - 2.0;
    float f = dot(fenc, fenc);
    float g = sqrt(1.0 - f/4);
    vec3 normal;
    normal.xy = fenc * g;
    normal.z = 1.0 - f/2;
    return normal;
}

float FresnelSchlick(float refl, float cos_theta)
{
    return refl + (1 - refl) * pow(1.0 - cos_theta, 5.0);
}

vertex shader
{
@PointLight
{
    layout(vb_pack_align = 4, vb_format = RGB32F)   in vec3 Position;
                                                    out vec2 iPosition;
}

                                                    flat out int DrawIndex;
                                                    out vec3 View;

void main()
{
    vec4 pos, spos;

    @PointLight
    {
        vec4 geom = Globals[tge_DrawID].LightGeometry;
        pos = vec4(Position*geom.w + geom.xyz, 1.0);
        spos = ViewProjectionTransform*pos;
        iPosition = spos.xy;
    }

    @DirectionalLight
    {
        spos = vec4(4.0*float(gl_VertexID & 1) - 1.0, 2.0*float(gl_VertexID & 2) - 1.0, 0.999999, 1.0);
        pos = ViewProjectionInverseTransform*spos;
        pos.xyz /= pos.w;
    }

    DrawIndex = tge_DrawID;

    gl_Position = spos;
    View = CameraPosition - pos.xyz;
}
}

fragment shader
{
@PointLight
{
    in vec2 iPosition;
}

flat in int DrawIndex;
in vec3 View;

out vec4 FragmentColor;

void main()
{
    vec3 incident_light;
    vec3 radiance;

    ivec2 tc = ivec2(gl_FragCoord.xy);

    @PointLight
    {
        float depth = 2.0*texelFetch(GBufferDepth, tc, 0).x - 1.0;
        vec4 vec = vec4(iPosition, depth, 1.0);
        vec4 position = ViewProjectionInverseTransform*vec;

        vec4 geom = Globals[DrawIndex].LightGeometry;
        vec3 dist_vec = geom.xyz - position.xyz/position.w;
        float dist = length(dist_vec);

        radiance = Globals[DrawIndex].Radiance/(dist*dist);

        incident_light = dist_vec/dist;
    }

    @DirectionalLight
    {
        radiance = Globals[DrawIndex].Radiance;
        incident_light = Globals[DrawIndex].LightDirection;
    }

    vec4 gbuffer0 = texelFetch(GBuffer0, tc, 0);
    vec3 diffuse = gbuffer0.xyz;
    float fresnel_factor = gbuffer0.w;

    vec4 gbuffer1 = texelFetch(GBuffer1, tc, 0);
    vec3 specular = gbuffer1.xyz;
    float specular_power = exp(gbuffer1.w)*100;
    
    vec4 gbuffer2 = texelFetch(GBuffer2, tc, 0);
    vec3 normal = LambertEqualAreaToCartesianCoordinates(gbuffer2.xy);
    // TODO: Tangent?

    vec3 view = normalize(View);

    float dotNormLight = max(0.0, dot(normal, incident_light));
    vec3 micro_norm = normalize(incident_light + view);
    specular *= pow(max(0.0, dot(normal, micro_norm)), specular_power);
    float cos_theta = clamp(dot(incident_light, micro_norm), 0.0, 1.0);
    float fresnel = FresnelSchlick(fresnel_factor, cos_theta);
	FragmentColor = vec4(dotNormLight * (diffuse + fresnel*specular*(specular_power + 8.0)*(1.0/8.0)) * (1.0 / 3.141592), 1.0);
} 
}