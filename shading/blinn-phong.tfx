/*   The MIT License
 *
 *   Tempest Engine
 *   Copyright (c) 2014 Zdravko Velinov
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */

options
{
    MaterialSpecular,
    MaterialAmbient,
    MaterialTexture
}

constant buffer SceneParams
{
    vec3 CameraPosition;
    vec3 SunDirection;
}

struct GlobalsDesc
{
    mat4 WorldViewProjectionTransform;
    mat4 WorldTransform;
    vec4 DiffuseReflectivity;              // Kd, sharpness
    @MaterialSpecular vec4 Specular;       // Ks, Ns
    @MaterialAmbient vec4 AmbientDissolve; // Ka, d (alpha)
//  vec4 Transmission;                     // Tf, Ni
    @MaterialTexture
    {
        vec4 DiffuseReflectivityMap;       // map_Kd
        @MaterialSpecular
        {
            vec4 SpecularReflectivityMap;  // map_Ks
            vec4 SpecularExponentMap;      // map_Ns
        }
        @MaterialAmbient vec4 AmbientReflectivityMap;   // map_Ka
    }
};

// The main reason is APIs that support some non-bindless weirdness for the old hardware sake.
resource buffer ResourcesTable
{
    sampler2DArray Textures[16];
}

structbuffer GlobalsDesc Globals;

// TODO: Position should be vec3

vertex shader
{
    layout(vb_pack_align = 4, vb_format = RGBA32F) in vec4 Position;
    @MaterialTexture layout(vb_pack_align = 4, vb_format = RG32F) in vec2 TexCoord;
    layout(vb_pack_align = 4, vb_format = RGB32F) in vec3 Normal;
    
    out vec2 InterpTexCoord;
    out vec3 InterpNormal;
    @MaterialSpecular out vec3 InterpView;
    
    flat out int DrawIndex;
    
    void main()
    {
        DrawIndex = tge_DrawID;
        @MaterialTexture InterpTexCoord = TexCoord;
        InterpNormal = mat3(Globals[tge_DrawID].WorldTransform)*Normal;
        @MaterialSpecular InterpView = CameraPosition - Position.xyz/Position.w;
        gl_Position = Globals[tge_DrawID].WorldViewProjectionTransform*Position;
    }
}

fragment shader
{
    flat in int DrawIndex;

    @MaterialTexture in vec2 InterpTexCoord;
    in vec3 InterpNormal;
    @MaterialSpecular in vec3 InterpView;
    
    out vec4 FragmentColor;
    
    void main()
    {
        @MaterialSpecular vec3 eye = normalize(InterpView);
        vec3 normal = normalize(InterpNormal);
        float alpha = 1.0;
        @MaterialAmbient
        {
            vec4 ambient = Globals[DrawIndex].AmbientDissolve;
            alpha = ambient.w;
        }
        vec4 diffuse = Globals[DrawIndex].DiffuseReflectivity;
        @MaterialSpecular vec4 specular = Globals[DrawIndex].Specular;
    
        @MaterialTexture
        {
            vec4 diffuse_tex = Globals[DrawIndex].DiffuseReflectivityMap;
            diffuse.xyz *= texture(Textures[uint(diffuse_tex.z)], vec3(InterpTexCoord*diffuse_tex.xy, float(diffuse_tex.w))).xyz;
            @MaterialAmbient
            {
                vec4 amb_tex = Globals[DrawIndex].AmbientReflectivityMap;
                if(all(equal(amb_tex.xy, vec2(0.0, 0.0))))
                {
                    ambient.xyz *= texture(Textures[uint(amb_tex.z)], vec3(InterpTexCoord*amb_tex.xy, float(amb_tex.w))).xyz;
                    // alpha *= texture(Textures[dissolve_slot], vec3(InterpTexCoord, float(dissolve_slice))).x;
                }
            }
            @MaterialSpecular
            {
                vec4 spec_tex = Globals[DrawIndex].SpecularReflectivityMap;
                vec4 spec_exp_tex = Globals[DrawIndex].SpecularExponentMap;
                if(all(equal(vec4(spec_tex.xy, spec_exp_tex.xy), vec4(0.0, 0.0, 0.0, 0.0))))
                {
                    specular.xyz *= texture(Textures[uint(spec_tex.z)], vec3(InterpTexCoord*spec_tex.xy, float(spec_tex.w))).xyz;
                    specular.w = texture(Textures[uint(spec_exp_tex.z)], vec3(InterpTexCoord*spec_exp_tex.xy, float(spec_exp_tex.w))).x;
                }
            }
        }

        vec3 color = diffuse.xyz*max(0.0, dot(SunDirection, normal));

        @MaterialSpecular
        {
            vec3 half_vec = normalize(eye + normal);
            color += specular.xyz*pow(clamp(dot(half_vec, SunDirection), 0.0, 1.0), specular.w);
        }

	 //   Don't care enough about it
     //   @MaterialAmbient color += ambient.xyz;
        
        FragmentColor = vec4(color, alpha);
    }
}